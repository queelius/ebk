import os
import sys
import json
import shutil
import csv
from pathlib import Path
import logging
import re
from typing import List, Optional
from datetime import datetime
import typer
from rich.console import Console
from rich.logging import RichHandler
from rich.progress import Progress
from rich.prompt import Confirm
from rich.traceback import install
from rich.table import Table

from .decorators import handle_library_errors
from .ident import add_unique_id

# Export functions (still available)
try:
    from .exports.hugo import export_hugo
    from .exports.zip import export_zipfile
    from .exports.jinja_export import JinjaExporter
except ImportError:
    export_hugo = None
    export_zipfile = None
    JinjaExporter = None

# Initialize Rich Traceback for better error messages
install(show_locals=True)

# Initialize Rich Console
console = Console()

# Configure logging to use Rich's RichHandler
logging.basicConfig(
    level=logging.INFO,  # Set to INFO by default, DEBUG if verbose
    format="%(message)s",
    datefmt="[%X]",
    handlers=[RichHandler(rich_tracebacks=True)]
)
logger = logging.getLogger(__name__)

app = typer.Typer()

@app.callback()
def main(
    ctx: typer.Context,
    verbose: bool = typer.Option(False, "--verbose", "-v", help="Enable verbose mode"),
):
    """
    ebk - eBook metadata management tool with SQLAlchemy + SQLite backend.

    Use db-* commands to manage your ebook library with full-text search,
    automatic text extraction, and hash-based deduplication.
    """
    if verbose:
        logger.setLevel(logging.DEBUG)
        console.print("[bold green]Verbose mode enabled.[/bold green]")


@app.command()
def about():
    """Display information about ebk."""
    console.print("[bold cyan]ebk - eBook Metadata Management Tool[/bold cyan]")
    console.print("")
    console.print("A powerful tool for managing ebook libraries with:")
    console.print("  • SQLAlchemy + SQLite database backend")
    console.print("  • Full-text search (FTS5)")
    console.print("  • Automatic text extraction from PDFs, EPUBs, plaintext")
    console.print("  • Hash-based file deduplication")
    console.print("  • Cover extraction and thumbnails")
    console.print("  • Import from Calibre libraries")
    console.print("")
    console.print("[bold]Database Commands:[/bold]")
    console.print("  ebk db-init <path>           Initialize new library")
    console.print("  ebk db-import <file> <lib>   Import ebook")
    console.print("  ebk db-import-calibre        Import from Calibre")
    console.print("  ebk db-search <query> <lib>  Full-text search")
    console.print("  ebk db-list <lib>            List books")
    console.print("  ebk db-stats <lib>           Show statistics")
    console.print("")
    console.print("[bold]Getting Started:[/bold]")
    console.print("  1. Initialize: ebk db-init ~/my-library")
    console.print("  2. Import: ebk db-import book.pdf ~/my-library")
    console.print("  3. Search: ebk db-search 'python' ~/my-library")
    console.print("")
    console.print("For more info: https://github.com/queelius/ebk")


# ============================================================================
# Database-backed Library Commands
# ============================================================================

@app.command()
def db_init(
    library_path: Path = typer.Argument(..., help="Path to create the library"),
    echo_sql: bool = typer.Option(False, "--echo-sql", help="Echo SQL statements for debugging")
):
    """
    Initialize a new database-backed library.

    This creates a new library directory with SQLite database backend,
    including directories for files, covers, and vector embeddings.

    Example:
        ebk db-init ~/my-library
    """
    from .library_db import Library

    library_path = Path(library_path)

    if library_path.exists() and any(library_path.iterdir()):
        console.print(f"[yellow]Warning: Directory {library_path} already exists and is not empty[/yellow]")
        if not Confirm.ask("Continue anyway?"):
            raise typer.Exit(code=0)

    try:
        lib = Library.open(library_path, echo=echo_sql)
        lib.close()
        console.print(f"[green]✓ Library initialized at {library_path}[/green]")
        console.print(f"  Database: {library_path / 'library.db'}")
        console.print(f"  Use 'ebk db-import' to add books")
    except Exception as e:
        console.print(f"[red]Error initializing library: {e}[/red]")
        raise typer.Exit(code=1)


@app.command()
def db_import(
    file_path: Path = typer.Argument(..., help="Path to ebook file"),
    library_path: Path = typer.Argument(..., help="Path to library"),
    title: Optional[str] = typer.Option(None, "--title", "-t", help="Book title"),
    authors: Optional[str] = typer.Option(None, "--authors", "-a", help="Authors (comma-separated)"),
    subjects: Optional[str] = typer.Option(None, "--subjects", "-s", help="Subjects/tags (comma-separated)"),
    language: str = typer.Option("en", "--language", "-l", help="Language code"),
    no_text: bool = typer.Option(False, "--no-text", help="Skip text extraction"),
    no_cover: bool = typer.Option(False, "--no-cover", help="Skip cover extraction"),
    auto_metadata: bool = typer.Option(True, "--auto-metadata/--no-auto-metadata", help="Extract metadata from file")
):
    """
    Import an ebook file into a database-backed library.

    Extracts metadata, text, and cover images automatically unless disabled.
    Supports PDF, EPUB, MOBI, and plaintext files.

    Examples:
        ebk db-import book.pdf ~/my-library
        ebk db-import book.epub ~/my-library --title "My Book" --authors "Author Name"
    """
    from .library_db import Library
    from .extract_metadata import extract_metadata

    if not file_path.exists():
        console.print(f"[red]Error: File not found: {file_path}[/red]")
        raise typer.Exit(code=1)

    if not library_path.exists():
        console.print(f"[red]Error: Library not found: {library_path}[/red]")
        console.print(f"[yellow]Initialize a library first with: ebk db-init {library_path}[/yellow]")
        raise typer.Exit(code=1)

    try:
        lib = Library.open(library_path)

        # Build metadata dict
        metadata = {}

        # Auto-extract metadata from file if enabled
        if auto_metadata:
            extracted = extract_metadata(str(file_path))
            metadata.update(extracted)

        # Override with CLI arguments
        if title:
            metadata['title'] = title
        if authors:
            metadata['creators'] = [a.strip() for a in authors.split(',')]
        if subjects:
            metadata['subjects'] = [s.strip() for s in subjects.split(',')]
        if language:
            metadata['language'] = language

        # Ensure title exists
        if 'title' not in metadata:
            metadata['title'] = file_path.stem

        # Import book
        book = lib.add_book(
            file_path,
            metadata,
            extract_text=not no_text,
            extract_cover=not no_cover
        )

        if book:
            console.print(f"[green]✓ Imported: {book.title}[/green]")
            console.print(f"  ID: {book.id}")
            console.print(f"  Authors: {', '.join(a.name for a in book.authors)}")
            console.print(f"  Files: {len(book.files)}")
        else:
            console.print("[yellow]Import failed or book already exists[/yellow]")

        lib.close()

    except Exception as e:
        console.print(f"[red]Error importing book: {e}[/red]")
        logger.exception("Import error details:")
        raise typer.Exit(code=1)


@app.command()
def db_import_calibre(
    calibre_path: Path = typer.Argument(..., help="Path to Calibre library"),
    library_path: Path = typer.Argument(..., help="Path to ebk library"),
    limit: Optional[int] = typer.Option(None, "--limit", help="Limit number of books to import")
):
    """
    Import books from a Calibre library into database-backed library.

    Reads Calibre's metadata.opf files and imports ebooks with full metadata.
    Supports all Calibre-managed formats (PDF, EPUB, MOBI, etc.).

    Examples:
        ebk db-import-calibre ~/Calibre/Library ~/my-library
        ebk db-import-calibre ~/Calibre/Library ~/my-library --limit 100
    """
    from .library_db import Library

    if not calibre_path.exists():
        console.print(f"[red]Error: Calibre library not found: {calibre_path}[/red]")
        raise typer.Exit(code=1)

    if not library_path.exists():
        console.print(f"[red]Error: Library not found: {library_path}[/red]")
        console.print(f"[yellow]Initialize a library first with: ebk db-init {library_path}[/yellow]")
        raise typer.Exit(code=1)

    try:
        lib = Library.open(library_path)

        # Find all metadata.opf files
        console.print(f"Scanning Calibre library...")
        opf_files = list(calibre_path.rglob("metadata.opf"))

        if limit:
            opf_files = opf_files[:limit]

        console.print(f"Found {len(opf_files)} books in Calibre library")

        if len(opf_files) == 0:
            console.print("[yellow]No books found. Make sure this is a Calibre library directory.[/yellow]")
            lib.close()
            raise typer.Exit(code=0)

        imported = 0
        failed = 0

        with Progress() as progress:
            task = progress.add_task("[green]Importing...", total=len(opf_files))

            for opf_path in opf_files:
                try:
                    book = lib.add_calibre_book(opf_path)
                    if book:
                        imported += 1
                    else:
                        failed += 1
                except Exception as e:
                    failed += 1
                    logger.debug(f"Failed to import {opf_path.parent.name}: {e}")

                progress.advance(task)

        console.print(f"[green]✓ Import complete[/green]")
        console.print(f"  Successfully imported: {imported}")
        if failed > 0:
            console.print(f"  Failed: {failed}")

        lib.close()

    except Exception as e:
        console.print(f"[red]Error importing Calibre library: {e}[/red]")
        logger.exception("Calibre import error details:")
        raise typer.Exit(code=1)


@app.command()
def db_search(
    query: str = typer.Argument(..., help="Search query"),
    library_path: Path = typer.Argument(..., help="Path to library"),
    limit: int = typer.Option(20, "--limit", "-n", help="Maximum number of results")
):
    """
    Search books in database-backed library using full-text search.

    Searches across titles, descriptions, and extracted text content using
    SQLite's FTS5 engine for fast, relevance-ranked results.

    Examples:
        ebk db-search "python programming" ~/my-library
        ebk db-search "machine learning" ~/my-library --limit 50
    """
    from .library_db import Library

    if not library_path.exists():
        console.print(f"[red]Error: Library not found: {library_path}[/red]")
        raise typer.Exit(code=1)

    try:
        lib = Library.open(library_path)

        results = lib.search(query, limit=limit)

        if not results:
            console.print(f"[yellow]No results found for: {query}[/yellow]")
        else:
            table = Table(title=f"Search Results: '{query}'")
            table.add_column("ID", style="cyan")
            table.add_column("Title", style="green")
            table.add_column("Authors", style="blue")
            table.add_column("Language", style="magenta")

            for book in results:
                authors = ", ".join(a.name for a in book.authors[:2])
                if len(book.authors) > 2:
                    authors += f" +{len(book.authors) - 2} more"

                table.add_row(
                    str(book.id),
                    book.title[:50],
                    authors,
                    book.language or "?"
                )

            console.print(table)
            console.print(f"\n[dim]Showing {len(results)} results[/dim]")

        lib.close()

    except Exception as e:
        console.print(f"[red]Error searching library: {e}[/red]")
        raise typer.Exit(code=1)


@app.command()
def db_stats(
    library_path: Path = typer.Argument(..., help="Path to library")
):
    """
    Show statistics for database-backed library.

    Displays book counts, author counts, language distribution,
    format distribution, and reading progress.

    Example:
        ebk db-stats ~/my-library
    """
    from .library_db import Library

    if not library_path.exists():
        console.print(f"[red]Error: Library not found: {library_path}[/red]")
        raise typer.Exit(code=1)

    try:
        lib = Library.open(library_path)

        stats = lib.stats()

        table = Table(title="Library Statistics")
        table.add_column("Metric", style="cyan")
        table.add_column("Count", style="green", justify="right")

        table.add_row("Total Books", str(stats['total_books']))
        table.add_row("Total Authors", str(stats['total_authors']))
        table.add_row("Total Subjects", str(stats['total_subjects']))
        table.add_row("Total Files", str(stats['total_files']))
        table.add_row("Books Read", str(stats['read_count']))
        table.add_row("Currently Reading", str(stats['reading_count']))

        console.print(table)

        # Language distribution
        if stats['languages']:
            console.print("\n[bold]Languages:[/bold]")
            for lang, count in sorted(stats['languages'].items(), key=lambda x: x[1], reverse=True):
                console.print(f"  {lang}: {count}")

        # Format distribution
        if stats['formats']:
            console.print("\n[bold]Formats:[/bold]")
            for fmt, count in sorted(stats['formats'].items(), key=lambda x: x[1], reverse=True):
                console.print(f"  {fmt}: {count}")

        lib.close()

    except Exception as e:
        console.print(f"[red]Error getting library stats: {e}[/red]")
        raise typer.Exit(code=1)


@app.command()
def db_list(
    library_path: Path = typer.Argument(..., help="Path to library"),
    limit: int = typer.Option(50, "--limit", "-n", help="Maximum number of books to show"),
    offset: int = typer.Option(0, "--offset", help="Starting offset"),
    author: Optional[str] = typer.Option(None, "--author", "-a", help="Filter by author"),
    subject: Optional[str] = typer.Option(None, "--subject", "-s", help="Filter by subject"),
    language: Optional[str] = typer.Option(None, "--language", "-l", help="Filter by language")
):
    """
    List books in database-backed library with optional filtering.

    Supports pagination and filtering by author, subject, or language.

    Examples:
        ebk db-list ~/my-library
        ebk db-list ~/my-library --author "Knuth"
        ebk db-list ~/my-library --subject "Python" --limit 20
    """
    from .library_db import Library

    if not library_path.exists():
        console.print(f"[red]Error: Library not found: {library_path}[/red]")
        raise typer.Exit(code=1)

    try:
        lib = Library.open(library_path)

        # Build query with filters
        query = lib.query()

        if author:
            query = query.filter_by_author(author)
        if subject:
            query = query.filter_by_subject(subject)
        if language:
            query = query.filter_by_language(language)

        query = query.order_by('title').limit(limit).offset(offset)

        books = query.all()
        total = query.count()

        if not books:
            console.print("[yellow]No books found[/yellow]")
        else:
            table = Table(title="Books")
            table.add_column("ID", style="cyan")
            table.add_column("Title", style="green")
            table.add_column("Authors", style="blue")
            table.add_column("Language", style="magenta")
            table.add_column("Formats", style="yellow")

            for book in books:
                authors = ", ".join(a.name for a in book.authors[:2])
                if len(book.authors) > 2:
                    authors += f" +{len(book.authors) - 2}"

                formats = ", ".join(f.format for f in book.files)

                table.add_row(
                    str(book.id),
                    book.title[:40],
                    authors[:30],
                    book.language or "?",
                    formats
                )

            console.print(table)
            console.print(f"\n[dim]Showing {len(books)} of {total} books (offset: {offset})[/dim]")

        lib.close()

    except Exception as e:
        console.print(f"[red]Error listing books: {e}[/red]")
        raise typer.Exit(code=1)


# ============================================================================
# Personal Metadata Commands (Tags, Ratings, Favorites, Annotations)
# ============================================================================

@app.command()
def db_rate(
    book_id: int = typer.Argument(..., help="Book ID"),
    library_path: Path = typer.Argument(..., help="Path to library"),
    rating: float = typer.Option(..., "--rating", "-r", help="Rating (0-5 stars)")
):
    """
    Rate a book (0-5 stars).

    Example:
        ebk db-rate 42 ~/my-library --rating 4.5
    """
    from .library_db import Library

    if not library_path.exists():
        console.print(f"[red]Error: Library not found: {library_path}[/red]")
        raise typer.Exit(code=1)

    if not (0 <= rating <= 5):
        console.print(f"[red]Error: Rating must be between 0 and 5[/red]")
        raise typer.Exit(code=1)

    try:
        lib = Library.open(library_path)
        lib.update_reading_status(book_id, "unread", rating=rating)

        book = lib.get_book(book_id)
        if book:
            console.print(f"[green]✓ Rated '{book.title}': {rating} stars[/green]")
        else:
            console.print(f"[yellow]Book {book_id} not found[/yellow]")

        lib.close()

    except Exception as e:
        console.print(f"[red]Error rating book: {e}[/red]")
        raise typer.Exit(code=1)


@app.command()
def db_favorite(
    book_id: int = typer.Argument(..., help="Book ID"),
    library_path: Path = typer.Argument(..., help="Path to library"),
    unfavorite: bool = typer.Option(False, "--unfavorite", "-u", help="Remove from favorites")
):
    """
    Mark/unmark a book as favorite.

    Examples:
        ebk db-favorite 42 ~/my-library
        ebk db-favorite 42 ~/my-library --unfavorite
    """
    from .library_db import Library

    if not library_path.exists():
        console.print(f"[red]Error: Library not found: {library_path}[/red]")
        raise typer.Exit(code=1)

    try:
        lib = Library.open(library_path)
        lib.set_favorite(book_id, favorite=not unfavorite)

        book = lib.get_book(book_id)
        if book:
            action = "Removed from" if unfavorite else "Added to"
            console.print(f"[green]✓ {action} favorites: '{book.title}'[/green]")
        else:
            console.print(f"[yellow]Book {book_id} not found[/yellow]")

        lib.close()

    except Exception as e:
        console.print(f"[red]Error updating favorite: {e}[/red]")
        raise typer.Exit(code=1)


@app.command()
def db_tag(
    book_id: int = typer.Argument(..., help="Book ID"),
    library_path: Path = typer.Argument(..., help="Path to library"),
    tags: str = typer.Option(..., "--tags", "-t", help="Tags (comma-separated)"),
    remove: bool = typer.Option(False, "--remove", "-r", help="Remove tags instead of adding")
):
    """
    Add or remove personal tags from a book.

    Examples:
        ebk db-tag 42 ~/my-library --tags "to-read,programming"
        ebk db-tag 42 ~/my-library --tags "to-read" --remove
    """
    from .library_db import Library

    if not library_path.exists():
        console.print(f"[red]Error: Library not found: {library_path}[/red]")
        raise typer.Exit(code=1)

    try:
        lib = Library.open(library_path)
        tag_list = [t.strip() for t in tags.split(',')]

        if remove:
            lib.remove_tags(book_id, tag_list)
            action = "Removed tags from"
        else:
            lib.add_tags(book_id, tag_list)
            action = "Added tags to"

        book = lib.get_book(book_id)
        if book:
            console.print(f"[green]✓ {action} '{book.title}': {', '.join(tag_list)}[/green]")
        else:
            console.print(f"[yellow]Book {book_id} not found[/yellow]")

        lib.close()

    except Exception as e:
        console.print(f"[red]Error updating tags: {e}[/red]")
        raise typer.Exit(code=1)


@app.command()
def db_note(
    book_id: int = typer.Argument(..., help="Book ID"),
    library_path: Path = typer.Argument(..., help="Path to library"),
    content: str = typer.Option(..., "--content", "-c", help="Note/annotation text"),
    page: Optional[int] = typer.Option(None, "--page", "-p", help="Page number"),
    note_type: str = typer.Option("note", "--type", "-t", help="Annotation type (note, highlight, bookmark)")
):
    """
    Add a note/annotation to a book.

    Examples:
        ebk db-note 42 ~/my-library --content "Great explanation of algorithms"
        ebk db-note 42 ~/my-library --content "Important theorem" --page 42
        ebk db-note 42 ~/my-library --content "Key passage" --type highlight
    """
    from .library_db import Library

    if not library_path.exists():
        console.print(f"[red]Error: Library not found: {library_path}[/red]")
        raise typer.Exit(code=1)

    try:
        lib = Library.open(library_path)
        annotation_id = lib.add_annotation(book_id, content, page=page, annotation_type=note_type)

        book = lib.get_book(book_id)
        if book:
            loc_info = f" (page {page})" if page else ""
            console.print(f"[green]✓ Added {note_type} to '{book.title}'{loc_info}[/green]")
            console.print(f"  Annotation ID: {annotation_id}")
        else:
            console.print(f"[yellow]Book {book_id} not found[/yellow]")

        lib.close()

    except Exception as e:
        console.print(f"[red]Error adding note: {e}[/red]")
        raise typer.Exit(code=1)


@app.command()
def db_notes(
    book_id: int = typer.Argument(..., help="Book ID"),
    library_path: Path = typer.Argument(..., help="Path to library")
):
    """
    List all notes/annotations for a book.

    Example:
        ebk db-notes 42 ~/my-library
    """
    from .library_db import Library

    if not library_path.exists():
        console.print(f"[red]Error: Library not found: {library_path}[/red]")
        raise typer.Exit(code=1)

    try:
        lib = Library.open(library_path)
        book = lib.get_book(book_id)

        if not book:
            console.print(f"[yellow]Book {book_id} not found[/yellow]")
            lib.close()
            raise typer.Exit(code=1)

        annotations = lib.get_annotations(book_id)

        if not annotations:
            console.print(f"[yellow]No notes found for '{book.title}'[/yellow]")
        else:
            console.print(f"\n[bold]Notes for: {book.title}[/bold]\n")

            for i, ann in enumerate(annotations, 1):
                type_info = f"[{ann.annotation_type}]" if ann.annotation_type else "[note]"
                page_info = f" Page {ann.page_number}" if ann.page_number else ""
                console.print(f"{i}. {type_info}{page_info}")
                console.print(f"   {ann.content}")
                console.print(f"   [dim]ID: {ann.id} | Added: {ann.created_at.strftime('%Y-%m-%d %H:%M')}[/dim]\n")

        lib.close()

    except Exception as e:
        console.print(f"[red]Error listing notes: {e}[/red]")
        raise typer.Exit(code=1)


# ============================================================================
# Export Commands
# ============================================================================

@app.command()
def db_export_json(
    library_path: Path = typer.Argument(..., help="Path to library"),
    output_file: Path = typer.Argument(..., help="Output JSON file"),
    include_annotations: bool = typer.Option(True, "--annotations/--no-annotations", help="Include annotations")
):
    """
    Export library to JSON format.

    Example:
        ebk db-export-json ~/my-library ~/backup.json
    """
    from .library_db import Library
    import json

    if not library_path.exists():
        console.print(f"[red]Error: Library not found: {library_path}[/red]")
        raise typer.Exit(code=1)

    try:
        lib = Library.open(library_path)
        books = lib.get_all_books()

        export_data = {
            "exported_at": datetime.now().isoformat(),
            "total_books": len(books),
            "books": []
        }

        for book in books:
            book_data = {
                "id": book.id,
                "unique_id": book.unique_id,
                "title": book.title,
                "subtitle": book.subtitle,
                "authors": [a.name for a in book.authors],
                "subjects": [s.name for s in book.subjects],
                "language": book.language,
                "publisher": book.publisher,
                "publication_date": book.publication_date,
                "description": book.description,
                "page_count": book.page_count,
                "word_count": book.word_count,
                "files": [{"format": f.format, "size": f.size_bytes, "path": f.path} for f in book.files],
                "created_at": book.created_at.isoformat(),
            }

            # Add personal metadata if exists
            if book.personal:
                book_data["personal"] = {
                    "reading_status": book.personal.reading_status,
                    "reading_progress": book.personal.reading_progress,
                    "rating": book.personal.rating,
                    "favorite": book.personal.favorite,
                    "tags": book.personal.personal_tags
                }

            # Add annotations if requested
            if include_annotations:
                annotations = lib.get_annotations(book.id)
                book_data["annotations"] = [
                    {
                        "id": ann.id,
                        "type": ann.annotation_type,
                        "content": ann.content,
                        "page": ann.page_number,
                        "position": ann.position,
                        "created_at": ann.created_at.isoformat()
                    }
                    for ann in annotations
                ]

            export_data["books"].append(book_data)

        # Write JSON file
        with open(output_file, 'w', encoding='utf-8') as f:
            json.dump(export_data, f, indent=2, ensure_ascii=False)

        console.print(f"[green]✓ Exported {len(books)} books to {output_file}[/green]")
        lib.close()

    except Exception as e:
        console.print(f"[red]Error exporting to JSON: {e}[/red]")
        raise typer.Exit(code=1)


@app.command()
def db_export_csv(
    library_path: Path = typer.Argument(..., help="Path to library"),
    output_file: Path = typer.Argument(..., help="Output CSV file")
):
    """
    Export library to CSV format.

    Example:
        ebk db-export-csv ~/my-library ~/books.csv
    """
    from .library_db import Library
    import csv

    if not library_path.exists():
        console.print(f"[red]Error: Library not found: {library_path}[/red]")
        raise typer.Exit(code=1)

    try:
        lib = Library.open(library_path)
        books = lib.get_all_books()

        # Write CSV file
        with open(output_file, 'w', newline='', encoding='utf-8') as f:
            writer = csv.writer(f)

            # Header
            writer.writerow([
                'ID', 'Title', 'Authors', 'Publisher', 'Publication Date',
                'Language', 'Subjects', 'Page Count', 'Rating', 'Favorite',
                'Reading Status', 'Tags', 'Formats'
            ])

            # Data
            for book in books:
                authors = '; '.join(a.name for a in book.authors)
                subjects = '; '.join(s.name for s in book.subjects)
                formats = ', '.join(f.format for f in book.files)

                rating = book.personal.rating if book.personal else None
                favorite = book.personal.favorite if book.personal else False
                status = book.personal.reading_status if book.personal else 'unread'
                tags = ', '.join(book.personal.personal_tags) if book.personal and book.personal.personal_tags else ''

                writer.writerow([
                    book.id,
                    book.title,
                    authors,
                    book.publisher or '',
                    book.publication_date or '',
                    book.language or '',
                    subjects,
                    book.page_count or '',
                    rating or '',
                    favorite,
                    status,
                    tags,
                    formats
                ])

        console.print(f"[green]✓ Exported {len(books)} books to {output_file}[/green]")
        lib.close()

    except Exception as e:
        console.print(f"[red]Error exporting to CSV: {e}[/red]")
        raise typer.Exit(code=1)


@app.command()
def db_vlib_add(
    book_id: int = typer.Argument(..., help="Book ID"),
    library_path: Path = typer.Argument(..., help="Path to library"),
    vlib: str = typer.Option(..., "--library", "-l", help="Virtual library name (e.g., 'computer-science', 'mathematics')")
):
    """
    Add a book to a virtual library (collection view).

    Virtual libraries allow organizing books into multiple collections.
    A book can belong to multiple virtual libraries.

    Examples:
        ebk db-vlib-add 1 ~/my-library --library computer-science
        ebk db-vlib-add 1 ~/my-library -l mathematics
    """
    from .library_db import Library

    if not library_path.exists():
        console.print(f"[red]Error: Library not found: {library_path}[/red]")
        raise typer.Exit(code=1)

    try:
        lib = Library.open(library_path)
        lib.add_to_virtual_library(book_id, vlib)

        book = lib.get_book(book_id)
        if book:
            console.print(f"[green]✓ Added '{book.title}' to virtual library '{vlib}'[/green]")

        lib.close()

    except Exception as e:
        console.print(f"[red]Error: {e}[/red]")
        raise typer.Exit(code=1)


@app.command()
def db_vlib_remove(
    book_id: int = typer.Argument(..., help="Book ID"),
    library_path: Path = typer.Argument(..., help="Path to library"),
    vlib: str = typer.Option(..., "--library", "-l", help="Virtual library name")
):
    """
    Remove a book from a virtual library.

    Example:
        ebk db-vlib-remove 1 ~/my-library --library computer-science
    """
    from .library_db import Library

    if not library_path.exists():
        console.print(f"[red]Error: Library not found: {library_path}[/red]")
        raise typer.Exit(code=1)

    try:
        lib = Library.open(library_path)
        lib.remove_from_virtual_library(book_id, vlib)

        book = lib.get_book(book_id)
        if book:
            console.print(f"[green]✓ Removed '{book.title}' from virtual library '{vlib}'[/green]")

        lib.close()

    except Exception as e:
        console.print(f"[red]Error: {e}[/red]")
        raise typer.Exit(code=1)


@app.command()
def db_vlib_list(
    library_path: Path = typer.Argument(..., help="Path to library"),
    vlib: Optional[str] = typer.Option(None, "--library", "-l", help="Show books in specific virtual library")
):
    """
    List all virtual libraries or books in a specific virtual library.

    Examples:
        ebk db-vlib-list ~/my-library                     # List all virtual libraries
        ebk db-vlib-list ~/my-library --library mathematics # List books in 'mathematics'
    """
    from .library_db import Library

    if not library_path.exists():
        console.print(f"[red]Error: Library not found: {library_path}[/red]")
        raise typer.Exit(code=1)

    try:
        lib = Library.open(library_path)

        if vlib:
            # Show books in this virtual library
            books = lib.get_virtual_library(vlib)

            if not books:
                console.print(f"[yellow]No books found in virtual library '{vlib}'[/yellow]")
            else:
                console.print(f"\n[bold]Virtual Library: {vlib}[/bold] ({len(books)} books)\n")

                table = Table(show_header=True, header_style="bold magenta")
                table.add_column("ID", style="dim")
                table.add_column("Title")
                table.add_column("Authors")

                for book in books:
                    authors = ", ".join(a.name for a in book.authors[:2])
                    if len(book.authors) > 2:
                        authors += "..."

                    table.add_row(
                        str(book.id),
                        book.title[:50] + "..." if len(book.title) > 50 else book.title,
                        authors
                    )

                console.print(table)
        else:
            # List all virtual libraries
            libraries = lib.list_virtual_libraries()

            if not libraries:
                console.print("[yellow]No virtual libraries found[/yellow]")
                console.print("[dim]Use 'ebk db-vlib-add' to create virtual libraries[/dim]")
            else:
                console.print(f"\n[bold]Virtual Libraries[/bold] ({len(libraries)} total)\n")

                for vlib_name in libraries:
                    books = lib.get_virtual_library(vlib_name)
                    console.print(f"  • {vlib_name} ({len(books)} books)")

        lib.close()

    except Exception as e:
        console.print(f"[red]Error: {e}[/red]")
        raise typer.Exit(code=1)


@app.command()
def db_view(
    book_id: int = typer.Argument(..., help="Book ID to view"),
    library_path: Path = typer.Argument(..., help="Path to library"),
    text: bool = typer.Option(False, "--text", help="Display extracted text in console"),
    page: Optional[int] = typer.Option(None, "--page", help="View specific page (for text mode)"),
    format_choice: Optional[str] = typer.Option(None, "--format", help="Choose specific format (pdf, epub, txt, etc.)")
):
    """
    View a book's content.

    Without --text: Opens the ebook file in the default application.
    With --text: Displays extracted text in the console with paging.
    """
    import subprocess
    import platform
    from .library_db import Library
    from .db.models import ExtractedText

    try:
        lib = Library.open(library_path)
        book = lib.get_book(book_id)

        if not book:
            console.print(f"[red]Book with ID {book_id} not found[/red]")
            lib.close()
            raise typer.Exit(code=1)

        if text:
            # Display extracted text in console
            # ExtractedText is linked to File, not Book directly
            extracted_text = None
            for file in book.files:
                if file.extracted_text and file.extracted_text.content:
                    extracted_text = file.extracted_text.content
                    break

            if not extracted_text:
                console.print(f"[yellow]No extracted text available for '{book.title}'[/yellow]")
                console.print("[dim]Try re-importing the book with text extraction enabled[/dim]")
                lib.close()
                raise typer.Exit(code=1)

            # Display book info
            console.print(f"\n[bold blue]{book.title}[/bold blue]")
            if book.authors:
                console.print(f"[dim]by {', '.join(a.name for a in book.authors)}[/dim]")
            console.print()

            # If page specified, try to show just that page
            # (This is approximate - we don't have exact page boundaries)
            if page is not None:
                # Estimate ~400 words per page
                words = extracted_text.split()
                words_per_page = 400
                start_idx = (page - 1) * words_per_page
                end_idx = start_idx + words_per_page

                if start_idx >= len(words):
                    console.print(f"[yellow]Page {page} exceeds document length[/yellow]")
                    lib.close()
                    raise typer.Exit(code=1)

                page_words = words[start_idx:end_idx]
                text_content = ' '.join(page_words)
                console.print(f"[dim]Approximate page {page} (words {start_idx+1}-{end_idx}):[/dim]\n")
                console.print(text_content)
            else:
                # Show full text with paging
                # Use rich pager for long text
                with console.pager(styles=True):
                    console.print(extracted_text)
        else:
            # Open file in default application
            if not book.files:
                console.print(f"[yellow]No files available for '{book.title}'[/yellow]")
                lib.close()
                raise typer.Exit(code=1)

            # Select file to open
            file_to_open = None
            if format_choice:
                # Find file matching requested format
                for f in book.files:
                    if f.format.lower() == format_choice.lower():
                        file_to_open = f
                        break
                if not file_to_open:
                    console.print(f"[yellow]No {format_choice} file found for this book[/yellow]")
                    console.print(f"Available formats: {', '.join(f.format for f in book.files)}")
                    lib.close()
                    raise typer.Exit(code=1)
            else:
                # Use first file (prefer PDF > EPUB > others)
                formats_priority = ['pdf', 'epub', 'mobi', 'azw3', 'txt']
                for fmt in formats_priority:
                    for f in book.files:
                        if f.format.lower() == fmt:
                            file_to_open = f
                            break
                    if file_to_open:
                        break

                if not file_to_open:
                    file_to_open = book.files[0]

            file_path = library_path / file_to_open.path

            if not file_path.exists():
                console.print(f"[red]File not found: {file_path}[/red]")
                lib.close()
                raise typer.Exit(code=1)

            console.print(f"[blue]Opening '{book.title}' ({file_to_open.format})[/blue]")

            # Open with default application based on OS
            system = platform.system()
            try:
                if system == 'Darwin':  # macOS
                    subprocess.run(['open', str(file_path)], check=True)
                elif system == 'Windows':
                    subprocess.run(['start', '', str(file_path)], shell=True, check=True)
                else:  # Linux and others
                    subprocess.run(['xdg-open', str(file_path)], check=True)

                console.print("[green]✓ File opened successfully[/green]")
            except subprocess.CalledProcessError as e:
                console.print(f"[red]Failed to open file: {e}[/red]")
                console.print(f"[dim]File location: {file_path}[/dim]")
                lib.close()
                raise typer.Exit(code=1)

        lib.close()

    except Exception as e:
        console.print(f"[red]Error viewing book: {e}[/red]")
        raise typer.Exit(code=1)


if __name__ == "__main__":
    app()
